[{"content":"简介 Git 可以非常方便的对文本文件做版本管理. 他可以记录每次修改后文件修改的位置和内容(前提是每次修改完成后进行提交, 即 commit). 通常情况下, Git是本地的, 如果需要将仓库放在网络上, 通常可以使用Github. 目前Github归微软所有.\n用途 一般来说, 我们可以把代码放在一个仓库中, 每次修改后及时提交, 并加上一些注释来说明本次修改做了哪些工作. 这样做有助于回到之前的某个时刻. 更重要的是, 有助于多人协作.\nTex 文件也是文本文件, 因此可以使用git来做版本控制. 这样一方面可以记录自己的科研工作, 以及当时的想法. 另外一方面, 如果遇到投稿, 修改稿子等工作时, 不用重新建立一个文件, 同时还可以清晰的比较两个版本之间的异同, 哪里被修改了. 这里不得不提一下, 很多人用日期来新建文件, 如\npaper-2022-03-01.tex paper-2022-03-03.tex paper-2022-03-27.tex, \u0026hellip; 这种做法除了占用空间以及比较混乱, 时间久了还很难知道两个文件之间有什么区别, 改动了哪里.\n使用方法 一般我们使用 github 来配合 git 进行版本管理. 因此, 我们需要下载 git 和 github desktop . 同时需要注册一个 github 账号来使用 github.\n之后使用 github 新建一个仓库 new repository, 选择一个空的文件夹, 并起一个仓库名, 如 test. github 会初始化一个 git 仓库, 里面有一个 git 文件夹.\n然后就可以把需要做版本控制的文件放在 test/ 文件夹下. 此时回到 github, 会看到提示增加了一个文件(如果是修改, 则会提示修改, 并突出显示修改了哪些地方).\n左下角有一个 commit 按钮, 填写一个此次提交的 summary (简单介绍干了啥), 具体的一些工作内容以及想法可以写在 description 中. 然后点击 commit 即可提交.\n提交以后, github 会提示是否需要同步到网络, 即 push. 此功能可以将本地仓库同步到 github 账号, 随时随地都可以下载, 进行查看, 修改和同步. 例如在工作室提交并同步以后, 回到家里面, 可以从网络仓库拉取到本地, 即 pull. 此时同样可以查看提交历史, 修改, 提交, 同步等.\n需要注意的是, 国内访问 github 不太稳定, 经常打不开. 可以使用网易uu加速器来加速访问.\n以下是一些图例:\n创建仓库 提交 查看版本 左侧显示提交历史, 右侧可以查看每次提交是修改了哪些文件以及各个文件修改了哪里. 常用命令 rebase 有时候完成某一点的修改, 中间提交了多次, 我们可以把它们合并成一次 commit. 这需要在git 命令行中输入(以最近的4次提交合并成一个为例)\ngit rebase -i HEAD~4 此时会打开一个窗口, 用来完成此次合并, 其内容为\npick 70d651c update: maple-latex # 倒数第四个 pick 8ef0aa9 update: maple-latex pick a96ed9e update: maple-latex pick 2cfc89e update: maple-latex # 最新的 # Rebase a7d2d47..2cfc89e onto a7d2d47 (4 commands) # ... 里面会显示最近四次提交的 summary. 因为四次提交做的是同一件事(当然, 每次提交都是在前一版本上做修改, 而且可能有不同的 description ), 所以我们可以把 最新的三次提交合并到倒数第四次, 将四次提交变成一次. 我们需要修改上述文件为\npick 70d651c update: maple-latex # 倒数第四个 s 8ef0aa9 update: maple-latex s a96ed9e update: maple-latex s 2cfc89e update: maple-latex # 最新的 # Rebase a7d2d47..2cfc89e onto a7d2d47 (4 commands) # ... 这里的 pick 表示保留该 commit, 而 s(squash) 则表示将此次 commit 合并到前一个 commit. 需要注意的是, 这四次提交合并的时候可能会出现冲突, 此时回到 github, 它会有一个弹窗, 告诉你哪些文件在合并的时候出现了冲突. 我们需要手动解决冲突, 一般来说选择最新的文件即可 (commit \u0026hellip; in \u0026hellip;).\npull request \u0026amp;\u0026amp; fetch upstream 这两个功能出现在多人协作中. 当我们Fork别人的代码进行修改, 提交到自己的仓库. 然后可以提Pull Request (PR), 等待原仓库作者审阅, 合并. 如果在修改过程中, 原仓库有了新的提交, 如果需要更新Fork过来的仓库, 可以使用fetch upstream功能.\n正常情况下, Github会给Fork的仓库上面提示和原仓库多了几次提交, 少了几次提交 对于多的, 我们可以Pull Request. 如果少了, 可以fetch upstream. 后者对于某些文件可能会出现冲突, 时我们可以根据github提示, 使用命令行工具进行修改. 在解决冲突文件时, 文件中会有如下的符号 \u0026laquo;\u0026laquo;\u0026lt; HEAD 这一部分是我们自己的修改 == = = = 这一部分是原作者的修改 \u0026gt; \u0026gt; b\u0026hellip; 对这一部分内容保留想要的即可解决冲突.\n","permalink":"https://jiandandaoxingfu.github.io/myblog/post/git/","summary":"介绍版本控制软件git的基本使用以及常用的命令","title":"Git-版本控制"},{"content":"简介 Maple-Latex 主要用来处理符号运算中， Maple, Mathematics, Tex三者之间数学公式的转化。 欢迎使用， 如出现错误， 可以把相应的tex代码和错误描述 发送至: jiaminxin@outlook.com。 或者到项目maple-latex提issue。\n功能 使用说明 略\n创建矩阵 可视化创建Tex矩阵/列表， 生成相应代码\nExcel转列表 复制Excel表格中的数据， 转为Tex列表\nlatex2maple 使用mathpix snipping tool识别PDF文件或图片中的数学公式， 将其生成的Tex代码复制在输入框， 点击按钮即可将Tex代码转成相应的Maple程序。 如果需要将Maple程序转为Mathematics程序， 可以再使用maple2mma功能。\n如下图所示: PDF(IMG) ==mathpix snipping tool==\u0026gt; Tex ==latex2maple==\u0026gt; Maple maple2mma 将Maple中的数学公式转为Mathematics公式， 主要是诸如sin(x) \u0026ndash;\u0026gt; Sin[x]之间的转化。 只需直接复制Maple输出的数学公式到输入框， 点击按钮即可。\nDT-gT \u0026amp; DT-coe 主要用于经典达布变换系数的整理。 不再维护。\n连续(离散)[szce]公式格式化 将Maple中的数学公式经latex函数转为Tex代码以后， 复制到输入框， 将其处理为正常的Tex代码， 如求导运算等。\n如下图所示: 展式系数格式化 守恒律相关， 不再维护。\ngrammarly 复制整个论文的Tex文件到输入框， 可以将其中的数学公式等相关信息删除， 然后使用Grammarly检查拼写及语法。\nTex格式化 复制整个论文的Tex文件到输入框， 对其格式化： 添加缩进， 断句(英文句号换行)。\ntypora 渲染typora生成的markdown文档(支持数学公式). 也可简单渲染tex文档.\n参考 create-react-app： 框架。 ant-design： 提供页面布局和UI。 remarkable： 渲染Markdown文档。 MathJax： 渲染数学公式。 ","permalink":"https://jiandandaoxingfu.github.io/myblog/post/maple-latex/","summary":"Maple-Latex使用文档","title":"Maple-Latex"},{"content":" 这里主要是记录一些平时用到的一些代码片段， 不定时更新。\n处理参考文献 良好的习惯是保持每条参考文献都是如下格式(下面我们的操作都以此为基础)\n\\bibitem{name} authors. title. journal ... 即每个参考文献按索引名， 作者， 标题， 刊信息分为四行，同时要求两个参考文献之间空一行。 这样做的好处在于方便统一修改。\n处理人名 不同期刊, 参考文献人名格式也不尽相同, 每次修改总是很麻烦(这里指使用\\bibitem环境). 主流期刊的人名格式([]表示可能有空格)以及他们对应的正则匹配\nM.[]X. Jia, M.[]X. Jia \u0026lt;=======\u0026gt; /([A-Z]\\. ?)+ ([a-z]+ )?[A-Z][^\\s,]+/g Jia, M.[]X., Jia, M.[]X. \u0026lt;=======\u0026gt; /([a-z]+ )?[A-Z][^\\s,]+, ([A-Z]\\. ?)+/g Jia M X, Jia M X \u0026lt;=======\u0026gt; /([a-z]+ )?[A-Z][^\\s,]+ ([A-Z]\\. ?)+/g 首先我们对参考文献进行处理, 得到文献作者列表\nvar bib = document.getElementById(\u0026#39;input\u0026#39;).value.split(/\\n/).filter( a =\u0026gt; a.match(\u0026#39;[a-z]\u0026#39;) ); var authors = []; for(let i=1; i\u0026lt;bib.length; i=i+4) authors.push( bib[i].replace(/and /, \u0026#39;, \u0026#39;) ); 然后根据不同的作者格式来匹配, 正常情况下, 匹配完成后, 只会剩下标点符号, 否则匹配失败.\n// 3 ---\u0026gt; 2; const regreps = [ \u0026#39;\u0026#39;, \u0026#39;([A-Z]\\\\. ?)+ (([a-z]+ )?[A-Z][^\\\\s,]+)\u0026#39;, \u0026#39;(([a-z]+ )?[A-Z][^\\\\s,]+), ([A-Z]\\\\. ?)+\u0026#39;, \u0026#39;(([a-z]+ )?[A-Z][^\\\\s,]+) ([A-Z] ?)+\u0026#39;, ]; const index_old = 3, index_new = 2, regrep_old = new RegExp( regreps[index_old] ), regrep_new = new RegExp( regreps[index_new] ), regrep_old_g = new RegExp( regreps[index_old], \u0026#39;g\u0026#39;); var authors_match = authors.map( a =\u0026gt; a.match( regrep_old_g ) ) var remaining = authors.map( a =\u0026gt; { let match = a.match( regrep_old_g ); match.forEach( m =\u0026gt; a = a.replace(m, \u0026#39;\u0026#39;) ); return a.match(/[A-Za-z]/); }) for( let i=0; i\u0026lt;authors.length; i++) { if( remaining[i] === null ) { authors_match[i].map( a =\u0026gt; a.match(regrep_old) ) } } 按照引用顺序排列参考文献 整理论文的参考文献时，没有使用bib文件， 想要按照引用的顺序来重新排列已经弄好的参考文献。 这里我们使用 Sublime-text 3 编辑器。 首先匹配tex文件中引用的文献索引名\n\\\\cite{.*?} 然后对其处理， 得到全部文献索引名构成的字符串数组(这里要求文献索引名由数字，字母，下划线，短横杠组成)\ncites_ = ` \\cite{...} ... \\cite{...} `.replaceAll(\u0026#34;cite\u0026#34;, \u0026#34;\u0026#34;).match(/[\\w-]+/g) // [ \u0026#34;ref1\u0026#34;, \u0026#34;ref2\u0026#34;, ... ] 我们还要去除里面重复的。 对于多次引用的， 只需要保留第一个\ncites = []; for (let cite of cites_) { if (cites.indexOf(cite) \u0026lt; 0) { cites.push(cite);\t} } 接下来处理参考文献。 这里我们将参考文献复制到Maple-Latex中， 然后利用javascript对其处理并重新排列\nrefs_ = $$(\u0026#39;#input\u0026#39;)[0].value.split(/\\\\bibitem/g).slice(1); // 按索引名生成字典 refs = {}; for (let ref of refs_) { let abbr = ref.match(/^{(.*?)}/)[1] refs[abbr] = \u0026#34;\\\\bibitem\u0026#34; + ref; }; // 根据引用索引名顺序排列参考文献 refs_ = \u0026#39;\u0026#39;; for (let cite of cites) { refs_ += refs[cite] + \u0026#39;\\n\u0026#39;; } $$(\u0026#39;#input\u0026#39;)[0].value = refs_.replaceAll(\u0026#39;\\n\\n\u0026#39;, \u0026#39;\\n\u0026#39;); 这样就可以了。\n按照姓氏字母排列参考文献 同样地， 我们可以对参考文献按照姓氏字母排列。 这只需对参考文献操作即可(这里参考文献最好能够符合4行格式)。 使用javascript对其处理\n// 拆分参考文献并获取作者列表 refs_ = $$(\u0026#34;#input\u0026#34;)[0].value.split(/\\\\bibitem/).slice(1).map( r =\u0026gt; \u0026#34;\\\\bibitem\u0026#34; + r ); authors_ = refs_.map( r =\u0026gt; r.match(/} *\\n(.*?)\\n/)[1] ) .map( a =\u0026gt; a.split(/(,| and)/) .filter( a =\u0026gt; (a !== \u0026#34;,\u0026#34;) \u0026amp;\u0026amp; (a !== \u0026#34; and\u0026#34;) ) ); 这样处理以后， 会根据文献格式得到不同的结果\n\u0026#34;姓, 名, 姓, 名\u0026#34; =\u0026gt; [\u0026#34;姓\u0026#34;, \u0026#34;名\u0026#34;, \u0026#34;姓\u0026#34;, \u0026#34;名\u0026#34;]\r\u0026#34;名, 姓, 名, 姓\u0026#34; =\u0026gt; [\u0026#34;名\u0026#34;, \u0026#34;姓\u0026#34;, \u0026#34;名\u0026#34;, \u0026#34;姓\u0026#34;]\r\u0026#34;姓 名, 姓 名\u0026#34; =\u0026gt; [\u0026#34;姓 名\u0026#34;, \u0026#34;姓 名\u0026#34;] 因为排序只比较姓氏， 因此， 我们只需获取每个参考文献的姓氏， 然后重排即可。 首先姓氏相加\nCase 1 authors = authors_.map( a =\u0026gt; a.reduce( (t, s, i) =\u0026gt; t + (i % 2 == 0 ? s : \u0026#34;\u0026#34;) ) ) .map( a =\u0026gt; a.replaceAll(\u0026#34; \u0026#34;, \u0026#34;\u0026#34;)); Case 2 authors = authors_.map( a =\u0026gt; a.reduce( (t, s, i) =\u0026gt; t + (i % 2 == 1 ? s : \u0026#34;\u0026#34;) ) ) .map( a =\u0026gt; a.replaceAll(\u0026#34; \u0026#34;, \u0026#34;\u0026#34;)); Case 3 authors = authors_.map( a =\u0026gt; a.map( a =\u0026gt; a.replace(/^\\s+/, \u0026#39;\u0026#39;).split(\u0026#39; \u0026#39;)[0] ) ) .map( a =\u0026gt; a.reduce( (i, j) =\u0026gt; i + j ) ) 然后\nrefs = {}; // 首先生成字典， 作者重复的， 加索引加以区分 for (i=0; i\u0026lt;refs_.length; i++) { if ( authors.slice(0, i).indexOf( authors[i] ) \u0026gt; -1 ) { authors[i] += i; } refs[ authors[i] ] = refs_[i]; } // 重排， 然后根据作者顺序排列参考文献 authors = authors.sort(); refs_ = \u0026#39;\u0026#39;; for (let author of authors) { refs_ += refs[author] + \u0026#39;\\n\u0026#39;; } $$(\u0026#39;#input\u0026#39;)[0].value = refs_.replaceAll(\u0026#39;\\n\\n\u0026#39;, \u0026#39;\\n\u0026#39;); ","permalink":"https://jiandandaoxingfu.github.io/myblog/post/snippets/","summary":"学习生活中用到的一些代码片段， 多是正则表示式。","title":"一些常用的代码片段"},{"content":"基本使用 定义变量 a := 3; # 定义变量不是用等号， 而是用冒号等号 b := 4: # 冒号不打印 c := 3 * 4; # 分号打印 f := a x^2 + b x + c; # 两个变量或者数字与变量的乘积可以省略乘号， 两个数字的乘积不能省略 # 这里#表示注释， 其后面的内容不会运行。 # 对所写程序添加注释是一个良好的代码习惯。 说明方法和目的， # 有助于自己和别人理解 变量类型\n矩阵\nwith(LinearAlgebra): # 使用矩阵及其操作， 需要引入线性代数包 M := Matrix( row, col ); # row * col阶矩阵 M := Matrix( row ) ; # row阶方阵 M[1, ..] # M的第一行(向量型) 列表\narr :=[1, 2, 3, 4]: arr[3] # return 3; 集合\narr := { 1, 2, 3, 4 }: 向量\narr := \u0026lt;1, 2, 3, 4\u0026gt;; 序列\narr := seq(1..3) # return 1, 2, 3 arr := [ seq(1..3) ] # return [1, 2, 3] arr := seq( i^2, i=1..3 ) # return 1, 4, 9 字典(table)\nT := table([ a = 1, b = x^2, c = \u0026#34;abcde\u0026#34; ]); # T[a] 字符串\ns := \u0026#34;i am a string\u0026#34;; 判断\nif x \u0026gt; 0 and (or) x \u0026lt; 4 then do something; end if; 循环 for i from 1 to 10 do do something; end do; arr := [1, 2, 3, 4]; for i in arr do do something; end do; 函数 func := (x) -\u0026gt; x^2: # 箭头函数 func := proc(x) return x^2; end proc: func(4) # return 16 常用命令 化简/因式分解/展开/ simplify / factor / expand 微分/积分 diff(f, x$k) / int(f, x) 求解方程(组) solve( eq = 0, x ) / solve({ eq1=b1, eq2=b2, ... }, { x1, x2, ... }) % 右端等于0可以省略 求解微分方程(组) dsolve( deq = 0, y ) / dsolve({ deq1=b1, deq2=b2, ... }, { y1, y2, ... }) % 右端等于0可以省略 公式拆解/获取自变量 op( f(x) ) # return x op( a + b c ) # return a, b c op( a b ) # return a, b 获取未知函数(量) indets( a f(x) + b ) # return { a, b, x, f(x) }; indets( a f(x) + b, Function ) # return { f(x) }; 变量转换 convert( 1/3, float ) # return 0.3333333... convert( f(x), string ) # return \u0026#34;f(x)\u0026#34; convert( \u0026#34;f(x)\u0026#34;, symbol ) # return f(x) convert( [1, 2, 3, 4], set ) # return {1, 2, 3, 4} evalf( 1/3 ) # return 0.33333... 复数操作 a := 3 + 4 I: b := a^* # return 3 - 4 I; [ Re(a), Im(a) ] # return [3, 4] evalc( expr ) # return Re(expr) + I Im(expr) 映射 arr := [ seq(1..3) ]; map( x-\u0026gt; x^2, arr ); # return [1, 4, 9] map可以替代for循环， 更加方便。 符号连接 cat(v, 1, 2) # return v12; seq(cat(v, i), i=1..3) # return v1, v2, v3 seq(seq(cat(v, i, j), i=1..3), j=1..3 ) # return v11, v12, ..., v33 Transpose(convert([seq(seq(cat(v, i, j), i = 1..3), j = 1..3)], Matrix, 3)) # return (vij)_{3*3} 绘图 plot( sin(x), x=-3..3 ); plot3d( sech^2(x/6 + t) , x=-3..3, t=-3..3); 文件读取 save var1, var2, ..., \u0026#34;path/var.m\u0026#34;; read \u0026#34;path/var.m\u0026#34;; 进阶 矩阵符号运算 符号计算中, 当不确定矩阵维数时, 需要保证不满足交换律, 同时保持求导等运算. Maple的Physics包中提供了可以定义符号变量为非交换元素, 从而可用于矩阵的符号运算中去. 具体使用如下: with(Physics): Setup(mathematicalnotation=true): Set(noncommutativeprefix={U, V, X, ... }): eq := U V - V U; # eq != 0. 示例 ","permalink":"https://jiandandaoxingfu.github.io/myblog/post/maple-symbolic-calculation/","summary":"Maple符号计算的快速入门教程","title":"Maple-符号计算"},{"content":"\r这里我们记录一下使用Maple自动推导离散谱问题的时间部分的$V$的形式。\n我们以$4$阶谱问题为例。 给定空间谱问题$U(n, \\lambda)=(U_{ij})_{4\\times 4}$ (这里我们限定$U$中的同一位势不重复出现)，我们设$V(n, \\lambda)=(V_{ij})_{4\\times 4}$，则静态零曲率方程 \\begin{equation} S=V^+U - UV = 0 \\end{equation} 是包含$16$个未知量的线性方程。\n我们的目的是构造恰当的$V$的形式，使得静态零曲率方程满足下面两个条件：\n(C1): 如果$ \\dfrac{\\partial U_{ij}}{\\partial n}\\neq 0$，则$S_{ij}$形如$A+\\lambda^k B=0$，其中$A，B$与谱参数$ \\lambda$无关，且$U_{ij}$中位势的系数为$\\lambda$的$0$次或者$k$次幂。\n(C2): 如果$ \\dfrac{\\partial U_{ij}}{\\partial n}= 0$，则$S_{ij}$形如$\\lambda^k A=0$，其中$A$与谱参数$\\lambda$无关。\n接下来我们给出Maple实现的思想和步骤。 记$ \\dfrac{\\partial U_{ij}}{\\partial n}= 0$所对应的$S$的子集为$S_0$。 我们分为两个步骤：\n第一步: 减少未知量的个数。 对于$eq\\in S_0$， 如果某个变量可以用其它变量表示出来，则将$S$中所有该变量替换。 此时，方程数和未知量个数都减少一个。 重复该操作，直到不存在某个变量可以用其它变量表示。 此时$S_0$剩余的式子仍记为$S_0$。\n第二步: 平衡$\\lambda$。 对于$eq\\in S_0$， 如果$\\lambda$的最大最小次幂不等， 则为了满足(C2)，我们将最低次幂的系数中的未知量替换为$\\lambda^k$乘以这些未知量， 使得该式达到平衡。 因此我们需要找到这些未知量，然后对$S$整体进行替换。 重复上述操作。\n对于不能满足(C2)或者满足(C2)但不满足(C1)的问题，我们无法给出$V$的形式。\n下面我们对程序中的函数做一些说明。\nsize: 返回向量，集合或者列表的元素个数。\nformat-szce: 消去(C2)中的$\\lambda^k$。\ncancel-var: 返回某个未知量用其它未知量表示的表达式。\nreduce-szce: 将上面的结果代入$S$，减少方程个数。\nfind-V: 返回需要乘以$\\lambda^k$的未知量。\nbalance-lambda: 将上面结果代入$S$， 平衡$\\lambda$。\ncheck: 检查$S$是否满足(C1)和(C2)。\n基于此， 我们也可以随机生成$U$，看是否可以找到满足(C1)和(C2)的$V$。 我们也用程序实现了这一想法， 这里我们不再描述。 这一方法很容易推广到连续谱问题，这里也不在给出。\n我们将程序放在Github代码库， 这里不在附上。\n","permalink":"https://jiandandaoxingfu.github.io/myblog/post/derive-hierarchy/","summary":"对于给定的谱问题U， 利用Maple自动导出方程族相应的V","title":"Maple自动推导方程族"},{"content":"\r这里我们记录一下使用Maple计算可求解差分方程(存在显式解的差分方程)的程序实现。\n首先，我们要求解的是关于$A$的形如下面的差分方程 \\begin{equation} \\begin{array}{l} A_m + F(\\dots, A_{-1}, A,\\dots, A_{m-1}) = G_{p}, \\end{array} \\end{equation} 其中$A_m = A(n+m)$，$F$是关于$A_{m-k}, k\\geq1$的有理函数(一般为变系数多项式)。 等式中与$A$无关的项全部归于$G_{p}$。 在给出程序之前， 我们首先考虑如何求解此类问题。 考虑一个简单的方程 \\begin{equation} \\begin{array}{l} A^+ + A = u^{++} - u. \\end{array} \\end{equation} 其解自然是$A=u^+ - u$(这里我们不考虑“积分常数”)。 我们思考一下我们是如何“自然”给出解的。 观察等式两端，显然$u^{++}$必然出自于$A^+$， 因此我们不妨做变换$A^{+}=A\u0026rsquo;^{+} + u^{++}$，代入方程得 \\begin{equation} \\begin{array}{l} A\u0026rsquo;^+ + A\u0026rsquo; = -u^+ - u. \\end{array} \\end{equation} 同理，我们做变换$A\u0026rsquo;^{+}=A\u0026rsquo;\u0026rsquo;^{+} - u^{+}$，则 \\begin{equation} \\begin{array}{l} A\u0026rsquo;\u0026rsquo;^+ + A\u0026rsquo;\u0026rsquo; = 0. \\end{array} \\end{equation} 由于我们不考虑“积分常数”，此时$A\u0026rsquo;\u0026rsquo;$自然为$0$。 从而 \\begin{equation} \\begin{array}{l} A = A\u0026rsquo; + u^{+} = A\u0026rsquo;\u0026rsquo; + u^+ - u = u^+ - u. \\end{array} \\end{equation} 我们发现以上的求解步骤中，遵循一个原则，即等式右端位移算子指数最大项$g_p$，来自于$A_m$。 然后我们做变换$A_m = A_m\u0026rsquo; + g_p $，得到新的方程 \\begin{equation} \\begin{array}{l} A_m\u0026rsquo; + F(\\dots, A\u0026rsquo;_{-1}, A\u0026rsquo;,\\dots, A\u0026rsquo;_{m-1}) = G_{p-1}\u0026rsquo;, \\end{array} \\end{equation} 重复上述步骤，即可得到 \\begin{equation} \\begin{array}{l} A_m^{\u0026rsquo;\\dots\u0026rsquo;} + F(\\dots, A_{-1}^{\u0026rsquo;\\dots\u0026rsquo;}, A^{\u0026rsquo;\\dots\u0026rsquo;}, \\dots, A_{m-1}^{\u0026rsquo;\\dots\u0026rsquo;} )= 0, \\end{array} \\end{equation} 从而取$A^{\u0026rsquo;\\dots\u0026rsquo;}=0$， 得$A_m = A_m^\u0026rsquo; + g_p = A_m^{\u0026rsquo;\u0026rsquo;} + g_p + g_{p-1}^\u0026rsquo; = \\dots$。 如果不能经过有限次得到上式， 那么我们认为该方程没有显式解。\n下面我们考虑用Maple实现上述的算法。 上述的讨论也即我们的算法思想， 其中的关键在于获取$G_p$中位移算子指数最大项$g_p$。 幸运的是， 我们可以通过Maple内置的op函数计算$g_p$。 这里我们简单说明如果利用op函数计算$g_p$。 对于一个由有理分式组成的“多项式”形如 \\begin{equation} \\begin{array}{l} expr = {\\dfrac {u ^{++} u ^{+++} u ^{++++} }{v ^{++} v ^{+++++} v ^{++++} }}-{\\dfrac {u ^{++} }{v ^{++} v ^{+++++} }}+{\\dfrac { \\left( u ^{++} \\right) ^{2}u ^{+++} }{ \\left( v ^{++} \\right) ^{2} v ^{++++} }} \\end{array} \\end{equation} 经op作用 op(expr) 可将上述“多项式”分解为多个单项式， 即按加法(减法可变为加法)拆分 \\begin{equation} \\begin{array}{l} {\\dfrac {u ^{++} u ^{+++} u ^{++++} }{v ^{++} v ^{+++++} v ^{++++} }}, \\ \\ \\ -{\\dfrac {u ^{++} }{v ^{++} v ^{+++++} }}, \\ \\ \\ +{\\dfrac { \\left( u ^{++} \\right) ^{2}u ^{+++} }{ \\left( v ^{++} \\right) ^{2} v ^{++++} }} \\end{array} \\end{equation} 而对于一个有理分式单项式， 即形如 \\begin{equation} \\begin{array}{l} expr = {\\dfrac {u ^{++} u ^{+++} u ^{++++} }{v ^{++} v ^{+++++} v ^{++++} }} \\end{array} \\end{equation} 经op作用可将其按乘法(除法可变为乘法)拆分，变为单个函数(对于倒数，需要再经op作用一次) \\begin{equation} \\begin{array}{l} u ^{++},\\ \\ u ^{+++},\\ \\ u ^{++++} ,\\ \\ \\left( v ^{++} \\right) ^{-1},\\ \\ \\left( v ^{+++} \\right) ^{-2},\\ \\ \\left( v ^{+++++} \\right) ^{-1},\\ \\ \\left( v ^{++++} \\right) ^{-1} \\end{array} \\end{equation} 最后， 对于单个函数， 经op作用可提取函数的自变量。 如对$u(n+2)$， 经op作用， 得$n+2$。 特别地， op作用于数字不变。 利用此特点， 我们取定$n$为一个足够大的数(这里是因为出现倒数时， 我们要多一次op作用， 因此我们对所有的项都做最大次(5次)的op叠加， 这样对于没有出现倒数的项， 如果不取定$n$， 则自变量会被进一步分解， 如$n+2$分解为$n, 2$，这样就无法判断大小)， 然后经5次op作用， 我们就可以获取多项式中位移算子的最大指数项。\n上述算法对于变系数差分方程，存在一定的问题，如对于 \\begin{equation} \\begin{array}{l} A^+ - \\dfrac{v^+}{v^{++}}A^{\u0026ndash;} = u^+ - \\dfrac{v^+}{v^{++}}u^{\u0026ndash;}. \\end{array} \\end{equation} 显然，它的解为$A^{+}=u^{+}$， 然而，位移算子的最大指数项是$\\dfrac{v^+u^{\u0026ndash;}}{v^{++}}$， 这导致算法无法求解。 原因在于变系数对算法造成了干扰， 目前我们还没有找到行之有效的方法避免这种情况。 实际求解中，我们可以将上述算法改为取位移算子的最小指数项， 那么该问题就解决了。 但是对于其它问题未必。 当然，对于一些问题，可以交叉使用两者。 另外一种办法是做变换$w=v^{\u0026mdash;\u0026mdash;}$，则其不再影响，求解以后再做逆变换即可。\n我们将程序放在Github代码库， 这里不在附上。\n","permalink":"https://jiandandaoxingfu.github.io/myblog/post/solve-difference-equation/","summary":"利用Maple求解差分方程的算法","title":"Maple求解差分方程"},{"content":"收集一些科研和论文写作中常用的网站.\n论文跟踪 除了在各大论文出版网站看最新出版的论文, 还有以下两个途径.\n孤立子与可积系统方向比较好的期刊(部分): Ann. Math., Math. Ann., Bull. Amer. Math. Soc., Mem. Amer. Math. Soc., Trans. Amer. Math. Soc., Proc. Amer. Math. Soc., Comm. Pure Math. Phys., Comm. Math. Phys., Adv. Math., Int. Math. Reseach. Notices., Ann. Inst. H. Poincaré Anal. Non Linéaire, Ann. Henri Poincare, Phys. Rev. Lett., Inverse Problems, Stud. Appl. Math., Nonlinearity, SIAM: J. Math. Appl, Phys. D, Chaos, Solitons \u0026amp; Fractals, J. Nonlinear Sci., J. Math. Phys, J. Phys. Soc. Japan, J. Differential Equation, J. Phys. A, Phys. Lett. A, ResearchGate ResearchGate 网站可以看做是学术微博. 首先在上面注册一个账号, 然后完善个人信息, 例如单位信息, 研究方向等. 之后它会推荐同一个单位的用户, 以及根据我们的研究领域来推荐该领域内的人. 然后我们就会看到关注的人的学术动态, 比如发表/添加/推荐/等一篇论文. 我们可以通过该平台下载文章, 也可以与关注的人进行交流.\narxiv (预印本网站) arxiv 网站供大家把自己未发表或者已投稿的论文放在上面. 一方面可以告诉别人这个东西自己已经做了, 另一方面也可以在正式发表之前让别人看到, 已提供交流建议. 除此之外, 它还有以下几个用途.\n查看别人论文的tex文件. 一般而言, arxiv中的论文除了提供PDF版本, 还会提供tex源文件(根据arxiv号打开页面, 选择 other format, 然后点击 Download sources, 最后给下载的文件后缀加上.tex 即可. 当然如果带有图片, 则此文件为压缩文件, 后缀应该加上.zip, 然后解压).\n可以看到自己感兴趣领域的最新进展. 因为论文正式发表往往需要数月, 而在arxiv上可以让及时看到别人的进展. arxiv 提供了免费订阅服务, 我们可以通过邮件来订阅自己感兴趣的领域, 之后它会在每个工作日把最新的论文通过邮件推送给我们.\n论文撰写以及拼写检查 grammarly grammarly 可以帮助我们检查论文中的拼写, 单复数, 用词不当等明显错误. 它提供在线版和桌面版两种方式, 都需要注册账号. 我们只需要使用免费版即可.\n当然, 由于未发表论文的隐私性, 我们在使用grammarly之前, 应该将论文里面的标题, 公式, 参考文献, 基金号等删除. 这可以借助在线工具 maple-latex 的 grammarly 功能来实现. 这个在线工具只在本地运行, 不会将内容上传到网络.\nnetspeak \u0026amp;\u0026amp; linggle netspeak 和 linggle 两个网站提供写作建议. 当写论文时, 有一些句子我们只知道一部分, 不知道接下来怎么说合适, 就可以用这两个网站. 他们可以根据输入, 提供大量的例句.\n常用数据库 论文检索 Web of Science 几乎覆盖所有数学领域的 SCI 论文信息且都提供强大的检索功能, 能够根据关键词等信息搜索相关的论文.\nMath Review: 美国数学评论, 会给每一个作者分配一个id, 记录几乎全部SCI论文信息. 写作论文参考文献的时候, 一般采用 Math Review 提供的作者, 期刊等信息. 可以查作者之间的联系等, 因为只包含数学方向论文呢, 因此比Web of Science更专业.\n期刊分区/国自然基金查询 letpub 和 中科院分区表查询期刊中科院分区.\n国自然: 查询国自然等信息.\n资源网站 \u0026amp;\u0026amp; 下载论文 Sci-hub \u0026amp;\u0026amp; Library Genesis Sci-hub1, Sci-hub2, Sci-hub3: 全球科研人员都在用的论文下载网站, 可以根据doi号下载论文(目前2022年论文大部分没有).\nLibrary Genesis: 此网站可以下载绝大部分论文和书籍(英文, 似乎需要翻墙, 或者使用上面iGG插件会员).\nProQuest, 国外学位论文中国集团全文检索平台: 国外博士论文查询, 不过这两个似乎都不支持下载全文, 只能预览一部分.\n工欲善其事必先利其器 谷歌学术 \u0026amp;\u0026amp; iGG谷歌学术助手 谷歌学术完全吊打百度学术, 但想要使用, 一般需要找镜像网站. 最简单的方法是安装一个插件, 比较好用的是iGG谷歌学术助手, 可以在Edge浏览器插件中心下载使用.\nTexlive + Sublime Text/Visual Studio 不管是Texlive还是Ctex都是编译tex文件的编辑器, 但是两者都很笨重而且不好用. 现在有很多优秀轻量的编辑器都支持调用Texlive或者Ctex来编译tex文件. 他们不仅提供了很多快捷键, 而且还支持非常丰富的插件, 比如tex代码自动补全, 自定义脚本, 数学公式预览等等. 因此选用这些编辑器, 如Sublime Text或Visual Studio是非常明智的选择.\nDjvu文件转PDF 下载部分书籍时, 可能会遇到Djvu文件, 可以用SumatraPDF查看. 下面的软件可以将Djvu文件转为PDF 论文写作 论文写作需要积累一些常用的句子, 表述等. 这可以通过每天读一些本领域大佬的论文, 或者是 arxiv 上的论文来积累. 读的时候可以不理解内容, 只需要把一些好的句子摘抄下来, 进行分类. 以下是一些笔记.\n个人笔记\nXiaohong Guan(Tsinghua Univ.)\nThe Most Common Habits from more than 200 English Papers written by Graduate Chinese Engineering Students (By Felicia Brittman)\n","permalink":"https://jiandandaoxingfu.github.io/myblog/post/sci-writting/","summary":"科研中一些常用的网站","title":"科研工具与论文写作"},{"content":"安装 首先下载Hugo程序，我们将其放在目录D:/Hugo/bin/hugo.exe。 然后将该路径添加到环境变量Path中...;D:/Hugo/bin/。 在命令行输入hugo version并回车，可以查看hugo的版本信息，则环境配置成功。\n然后我们就可以使用命令行工具创建网站项目。 创建网站项目名为mysite，放在E盘\nE:\\\u0026gt; hugo new site mysite 回车即初始化项目，可以得到E:/mysite/文件夹，包含以下文件(夹)\narchetypes/ content/ data/ layouts/ static/ themes/ config.toml 这样我们就创建了一个空的项目。\n主题 Hugo有很多适配的主题，免去了我们重新设计的麻烦。 这里我们使用主题PaperMod来说明如何使用。\n首先将该仓库下载解压至E:/mysite/themes/papermod文件夹下， 它包含以下文件(夹)\n.git/ .github/ assets/ i18n/ layouts/ ... 前两个github库相关文件夹可以删除。 然后我们就可以创建页面。 命令行输入(当然也可以用记事本等软件新建md文件)\nE:\\mysite\u0026gt; hugo new post/first/index.md 回车即成功创建文件E:/mysite/content/post/first/index.md。 命令行启动server\nE:\\mysite\u0026gt; hugo server -t papermod --buildDrafts 回车即返回编译成功，并生成地址：localhost:1313。 用浏览器打开该地址， 即可得到我们的主页面 可以看到我们创建的第一个文件first。\n我们可以对主页面进行如下配置。 将文件E:/mysite/config.toml重命名为config.yml，内容修改为\npublishDir: docs baseURL: \u0026#34;https://jiandandaoxingfu.github.io/hugo-papermod\u0026#34; title: hugo-papermod paginate: 5 theme: PaperMod enableRobotsTXT: true buildDrafts: true buildFuture: false buildExpired: false minify: disableXML: true minifyOutput: true params: env: production title: hugo-papermod description: hugo-papermod keywords: [Hugo, PaperMod] author: JMx DateFormat: \u0026#34;January 2, 2006\u0026#34; defaultTheme: auto # dark, light disableThemeToggle: false ShowReadingTime: true ShowShareButtons: false ShowPostNavLinks: true ShowBreadCrumbs: true ShowCodeCopyButtons: false disableSpecial1stPost: false disableScrollToTop: false comments: true hidemeta: false hideSummary: false showtoc: true tocopen: false assets: favicon: https://jiandandaoxingfu.github.io/hugo-papermod/favicon.ico favicon16x16: https://jiandandaoxingfu.github.io/hugo-papermod/favicon.ico favicon32x32: https://jiandandaoxingfu.github.io/hugo-papermod/favicon.ico apple_touch_icon: https://jiandandaoxingfu.github.io/hugo-papermod/favicon.ico safari_pinned_tab: https://jiandandaoxingfu.github.io/hugo-papermod/favicon.ico label: text: \u0026#34;Home\u0026#34; icon: https://jiandandaoxingfu.github.io/hugo-papermod/favicon.ico iconHeight: 35 cover: hidden: false # hide everywhere but not in structured data hiddenInList: false # hide on list pages and home hiddenInSingle: false # hide on single page fuseOpts: isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 0.6 minMatchCharLength: 3 keys: [\u0026#34;title\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34;, \u0026#34;permalink\u0026#34;] menu: main: - identifier: archives name: Archives url: /archives/ weight: 10 - identifier: categories name: Categories url: /categories/ weight: 20 - identifier: tags name: Tags url: /tags/ weight: 30 - identifier: search name: Search url: /search/ weight: 40 - identifier: about name: About url: /about/ weight: 50 outputs: home: - HTML - RSS - JSON 有如下几点需要注意:\npublishDir: docs, 这里是指将项目生成的静态文件放在E:/mysite/docs/文件夹下， 便于我们后面将项目发布到github pages。\nbaseURL: https://username.github.io/hugo-papermod/是我们github pages的主目录。 即我们将整个仓库放在hugo-papermod仓库中。\nicon地址需要是绝对地址， 发布以后切换页面时才可以正常显示图标。 其中assets是网站图标， label是主页面标题的图标。\n为了让主页面的几个按钮正常工作， 我们需要创建几个文件\nE:/mysite/content/about.md --- title: \u0026#34;Who Am I?\u0026#34; # url: \u0026#34;/about\u0026#34; # description: \u0026#34;Description for about\u0026#34; summary: \u0026#34;about\u0026#34; searchHidden: true showToc: false hidemeta: true ShowBreadCrumbs: false ShowReadingTime: false ShowPostNavLinks: false --- --- \u0026lt;!-- content --\u0026gt; E:/mysite/content/archives.md --- title: \u0026#34;Archives\u0026#34; layout: \u0026#34;archives\u0026#34; summary: \u0026#34;archives\u0026#34; --- E:/mysite/content/search.md --- title: \u0026#34;Search\u0026#34; layout: \u0026#34;search\u0026#34; summary: \u0026#34;search\u0026#34; --- 这样就基本完成了主页面。\n对于子页面， 放在E:/mysite/content/post/文件夹下就可以了。 例如我们更改E:/mysite/content/post/first/index.md为\n--- title: \u0026#34;first\u0026#34; date: 2022-01-06 18:13:52.872 +0800 summary: \u0026#39;How to use hugo with the theme \u0026#34;paperMod\u0026#34;\u0026#39; weight: 1 tags: [\u0026#34;first\u0026#34;, \u0026#34;two\u0026#34;] categories: [\u0026#34;first\u0026#34;] author: \u0026#34;JMx\u0026#34; showToc: true TocOpen: false draft: true hidemeta: false comments: false disableHLJS: true disableShare: true hideSummary: false searchHidden: false ShowReadingTime: true ShowBreadCrumbs: true ShowPostNavLinks: true --- ## content 则此页面显示为 至此我们完成了基本功能。 需要注意的是，我们将此页面引用的图片放在E:/mysite/content/post/first/images/文件夹下。\n配置数学环境 下面， 我们使其支持数学环境。 创建模板文件E:/mysite/themes/papermod/layouts/shortcodes/katex.html， 这里我们使用katex：\n\u0026lt;div id=\u0026#34;katex-support\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css\u0026#34; integrity=\u0026#34;sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js\u0026#34; integrity=\u0026#34;sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js\u0026#34; integrity=\u0026#34;sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function() { renderMathInElement(document.body, { delimiters: [ {left: \u0026#39;$$\u0026#39;, right: \u0026#39;$$\u0026#39;, display: true}, {left: \u0026#39;$\u0026#39;, right: \u0026#39;$\u0026#39;, display: false}, {left: \u0026#34;\\\\begin{equation}\u0026#34;, right: \u0026#34;\\\\end{equation}\u0026#34;, display: true}, {left: \u0026#34;\\\\begin{cases}\u0026#34;, right: \u0026#34;\\\\end{cases}\u0026#34;, display: true}, {left: \u0026#34;\\\\begin{pmatrix}\u0026#34;, right: \u0026#34;\\\\end{pmatrix}\u0026#34;, display: true}, {left: \u0026#34;\\\\begin{array}\u0026#34;, right: \u0026#34;\\\\end{array}\u0026#34;, display: true}, {left: \u0026#34;\\\\begin{align}\u0026#34;, right: \u0026#34;\\\\end{align}\u0026#34;, display: true} ], throwOnError : false }); }); \u0026lt;/script\u0026gt; \u0026lt;/div\u0026gt; 然后只需要在用到数学公式的文章开头引入该模板。 为了查看效果， 我们在E:/mysite/content/post/first/index.md文件中追加如下代码\n... --- {%{\u0026lt; katex \u0026gt;}} % 删除\u0026#34;%\u0026#34;. ## content 这是一个行内公式： $a^2+b^2=1$. 下面的是块级公式 $$ x^2+y^2=1 $$ 支持以下数学环境 \\begin{pmatrix} a \u0026amp; b \\\\\\\\ c \u0026amp; d \\end{pmatrix} \\begin{equation} \\begin{array}{l} \u0026amp; x^2 = 1, \\\\\\\\ \u0026amp; y^2 = 2, \\\\\\\\ \u0026amp; z^2 = 3. \\end{array} \\end{equation} \\begin{equation} x^2 + y^2 = 1. \\end{equation} $$ x = \\begin{cases} a \u0026amp;\\text{if } b \\\\\\\\ c \u0026amp;\\text{if } d \\end{cases} $$ 则有 需要注意的是， 下划线作为markdown特殊词义， 我们需要将公式中的下划线转义，即使用\\_。\n支持PDF文件阅读 类似于数学环境， 我们可以引入pdf.js来支持pdf文件阅读。 首先下载pdfjs， 解压后将其放在E:/msite/static/js/pdf-js/文件夹下。 删除不必要文件后，结构如下\npdf-js/web/viewer.html pdf-js/web/viewer.js pdf-js/web/viewer.css pdf-js/web/images/ pdf-js/build/pdf.js pdf-js/build/pdf.worker.js 然后修改viewer.js文件。 首行添加命令\nconst _url_ = window.location.href.split(\u0026#34;?\u0026#34;)[1]; 然后将文件中默认打开的文件compressed.tracemonkey-pldi-09.pdf改为_url_。 接着创建文件E:/mysite/themes/papermod/layouts/shortcodes/embed-pdf.html\n\u0026lt;div id=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var url = \u0026#34;{{.Site.BaseURL}}\u0026#34; + \u0026#39;{{ .Get \u0026#34;url\u0026#34; }}\u0026#39;; var div = document.getElementById(\u0026#39;container\u0026#39;); div.innerHTML += `\u0026lt;iframe src=/hugo-papermod/js/pdf-js/web/viewer.html?${url} frameborder=\u0026#34;0\u0026#34; width=\u0026#34;100%\u0026#34; height=\u0026#34;900px\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt;` \u0026lt;/script\u0026gt; \u0026lt;/div\u0026gt; 同样地，我们在需要引入pdf文件的文章中添加\n{%{\u0026lt; embed-pdf url=\u0026#34;post/first/files/test.pdf\u0026#34; \u0026gt;}} % 删除\u0026#34;%\u0026#34; 结果如下 部署到Github Pages 下面， 我们将上述项目放在github中， 并启用github pages。 首先用hugo生成静态页面\nE:\\mysite\u0026gt; hugo 回车后hugo会将文章生成html页面， 放在docs文件夹下。 然后我们创建仓库hugo-papermod(前面我们已经假设此仓库建好了，并且有icon图片)。 然后打开github pages， 选择main-\u0026gt;docs保存发布即可访问。\n总结 上面我们只是简单说该主题如何使用， 并没有过多介绍config.xml文件， 对其不同设置， 可以得到不同的主页面， 参见\nhttps://gohugo.io/\nhttps://adityatelange.github.io/hugo-PaperMod/\nhttps://chrispanag.com/\nhttps://github.com/anvithks/hugo-embed-pdf-shortcode\n","permalink":"https://jiandandaoxingfu.github.io/myblog/post/hugo-papermod/","summary":"How to use hugo with the theme \u0026ldquo;paperMod\u0026rdquo;","title":"Hugo使用教程"}]